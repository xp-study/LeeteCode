# 归并排序（Merge Sort）

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

### 算法描述

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

### 动画演示

![归并排序](./images/归并排序/归并排序1.gif)

### 代码实现

```java
	public static void mergeSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		mergeSort(arr, 0, arr.length - 1);
	}

	// 当数组的左边界与右边界相等则返回
	public static void mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return;
		}
		// 获取数组的中间值
		int mid = l + ((r - l) >> 1);// mid =r+(r-l)/2 安全的操作
		// 递归排序数组的左半部分,边界值为mid
		mergeSort(arr, l, mid);
		// 递归排序数组的右半部分，边界值为mid+1
		mergeSort(arr, mid + 1, r);
		// 合并数组的左半部分和右半部分
		merge(arr, l, mid, r);
	}

	// 合并数组的左半部分和右半部分,使用外排
	public static void merge(int[] arr, int l, int m, int r) {
		// 定义一个辅助数组
		int[] help = new int[r - l + 1];
		int i = 0;
		// 定义2个指针,第一个指针的初始值为数组左半部分的边界
		// 第二个指针的初始值为数组右半部分的边界
		int p1 = l;
		int p2 = m + 1;
		// 遍历的条件是第一个指针小于中间值
		// 并且第二个指针小于数组的右边界
		// 比较左右2部分数组对应指针的值
		// 将较小的值赋给辅助数组
		// 辅助数组的指针和被赋值的指针都往后移动一位
		while (p1 <= m && p2 <= r) {
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 当前一个遍历完成后,一定至少有一个数组遍历完了
		// 现在开始判断是哪个数组没有遍历完,同时将这个数组剩余的值全部赋值给辅助数组
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		// 最后将辅助数组的值全部拷贝回原数组
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i];
		}
	}
```

