#### 1947. 最大兼容性评分和

有一份由 `n` 个问题组成的调查问卷，每个问题的答案要么是 `0`（no，否），要么是 `1`（yes，是）。

这份调查问卷被分发给 m 名学生和 m 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 students 表示，其中 students[i] 是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组 mentors 表示，其中 mentors[j] 是一个整数数组，包含第 j 名导师对调查问卷给出的答案（下标从 0 开始）。

每个学生都会被分配给 **一名** 导师，而每位导师也会分配到 **一名** 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。

* 例如，学生答案为`[1, 0，1]` 而导师答案为 `[0, 0，1]` ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。

请你找出最优的学生与导师的配对方案，以 **最大程度上** 提高 **兼容性评分和** 。

给你 `students` 和 `mentors` ，返回可以得到的 **最大兼容性评分和** 。

**示例 1：**

```shell
输入：students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
输出：8
解释：按下述方式分配学生和导师：
- 学生 0 分配给导师 2 ，兼容性评分为 3 。
- 学生 1 分配给导师 0 ，兼容性评分为 2 。
- 学生 2 分配给导师 1 ，兼容性评分为 3 。
最大兼容性评分和为 3 + 2 + 3 = 8 。
```

**示例 2：**

```shell
输入：students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
输出：0
解释：任意学生与导师配对的兼容性评分都是 0 。
```

**提示：**

* `m == students.length == mentors.length`
* `n == students[i].length == mentors[j].length`
* `1 <= m, n <= 8`
* `students[i][k] 为 0 或 1`
* `mentors[j][k] 为 0 或 1`

### 题解

#### 状态压缩动态规划

**思路与算法**

我们按照编号顺序给每一名学生分配老师。

我们可以用一个长度为 m 的二进制数 mask 表示每一名老师是否被分配了学生。如果 mask 的第 i 位为 1，那么第 i 位老师被分配到了学生，否则就没有被分配到学生。

这样一来，我们就可以用状态压缩动态规划解决本题了。记 f[mask] 表示当老师被分配学生的状态为 mask 时，最大的兼容性评分和。由于我们规定了按照编号顺序给每一名学生分配老师，那么 mask 中包含 c 个 1，就说明我们分配的学生编号为 0, 1, ⋯,c−1。

因此，在进行状态转移时，我们可以枚举编号为 c-1 的学生被分配的是哪一名老师，这样就可以得到状态转移方程：

![image-20210912213301249](./images/最大兼容性评分和/1.jpg)

其中 mask\i 表示将mask 的第 i 位从 1 变成 0，g表示预处理得到每对师生间的兼容性评分

最终的答案即为 f*[2*m−1]。

```java
class Solution {
    public int maxCompatibilitySum(int[][] students, int[][] mentors) {
        int m = students.length;
        int n = students[0].length;

        //预处理得到每对师生间的兼容性评分
        int[][] score = new int[m][m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < m; j++) {
                score[i][j] = 0;
                for (int k = 0; k < n; k++) {
                    if (students[i][k] == students[j][k]) {
                        score[i][j]++;
                    }
                }
            }
        }

        // 状态压缩 + 动态规划
        // 压缩后的范围[0,2^m-1]
        int mask = (1 << m) - 1;
        // dp[i]中i的第x位为1，表示第x位导师已被分配，为0表示该导师尚未分配，dp[i]表示该分配状态下当前的最大兼容性评分和
        int[] dp = new int[mask + 1];
        // 初始化
        Arrays.fill(dp, 0);
        // 遍历所有可能的分配状态
        for (int i = 0; i <= mask; i++) {
            // i中有count位为1，说明正在分配导师的是第count-1位学生
            int count = Integer.bitCount(mask);
            // 尝试匹配所有导师
            for (int j = 0; j < m; j++) {
                // 判断 i 的第 j 位是否为 1
                if (((i >> j) & 1) == 1) {
                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)] + score[count - 1][j]);
                }
            }
        }

        return dp[mask];
    }
}
```

