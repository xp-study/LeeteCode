# **选择排序（Selection Sort）**

表现**最稳定的排序算法之一**，因为**无论什么数据进去都是O(n2)的时间复杂度**，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

### 算法描述

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

- 初始状态：无序区为R[1..n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。

### 动画演示

![选择排序](./images/选择排序/选择排序1.gif)

### 代码实现

```java
	// 选择排序
	// 从数组下标为0的数开始往后遍历，找到最小的值后与下标为0的值替换
	// 接着从下标为1的数开始往后遍历，找到最小的值后与下标为1的值替换
	// 依次类推
	// 直到下标达到数据长度
	public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) {
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
```

# 归并排序（Merge Sort）

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

### 算法描述

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

### 动画演示

![归并排序](./images/归并排序/归并排序1.gif)

### 代码实现

```java
	public static void mergeSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		mergeSort(arr, 0, arr.length - 1);
	}

	// 当数组的左边界与右边界相等则返回
	public static void mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return;
		}
		// 获取数组的中间值
		int mid = l + ((r - l) >> 1);// mid =r+(r-l)/2 安全的操作
		// 递归排序数组的左半部分,边界值为mid
		mergeSort(arr, l, mid);
		// 递归排序数组的右半部分，边界值为mid+1
		mergeSort(arr, mid + 1, r);
		// 合并数组的左半部分和右半部分
		merge(arr, l, mid, r);
	}

	// 合并数组的左半部分和右半部分,使用外排
	public static void merge(int[] arr, int l, int m, int r) {
		// 定义一个辅助数组
		int[] help = new int[r - l + 1];
		int i = 0;
		// 定义2个指针,第一个指针的初始值为数组左半部分的边界
		// 第二个指针的初始值为数组右半部分的边界
		int p1 = l;
		int p2 = m + 1;
		// 遍历的条件是第一个指针小于中间值
		// 并且第二个指针小于数组的右边界
		// 比较左右2部分数组对应指针的值
		// 将较小的值赋给辅助数组
		// 辅助数组的指针和被赋值的指针都往后移动一位
		while (p1 <= m && p2 <= r) {
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 当前一个遍历完成后,一定至少有一个数组遍历完了
		// 现在开始判断是哪个数组没有遍历完,同时将这个数组剩余的值全部赋值给辅助数组
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		// 最后将辅助数组的值全部拷贝回原数组
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i];
		}
	}
```

